# 10-7

## 下面程序是否有错误?如果有，请改正。

(a)
```c++

vector<int> vec;
list<int> lst;
int i;

while(cin>>i)
    lst.push_back(i);

copy(lst.cbegin(),lst.cend(),vec.begin());

```

(b)
```c++

vector<int> vec;
vec.reserve(10);
fill_n(vec.begin(),10,0);

```

## (a)是错误的。因为泛型算法的一个基本特点是：算法总是通过迭代器操作容器，因此不能直接向/从容器添加、删除元素，无法改变容器大小。因此，对于 _copy_ 算法，要求目标序列至少要包含与源序列一样多的元素。而此程序中，_vec_ 进行缺省初始化，它是空的，_copy_ 无法进行。如需改变容器大小，需要使用一类特殊的称为插入器的迭代器。我们可以将第三个参数改为 _back_inserter(vec)_ ,通过它,_copy_ 算法即可将 _lst_ 中元素的拷贝插入到 _vec_ 的末尾。

## (b) 这段程序仍然是错误的。粗看起来，_reserve_ 为 _vec_ 分配了至少能容纳10个 _int_ 的内存空间，调用 _fill_n_ 时，_vec_ 已有足够空间。但泛型算法对于容器的要求并不是有足够的空间，而是足够的元素。此时 _vec_ 仍然为空，没有任何元素。而算法又不具备向容器添加元素的能力，因此 _fill_n_ 仍然失败。这里，我们还是需要使用 _back_inserter_ 来让 _fill_n_ 有能力向 _vec_ 添加元素。其实，只有0有能力做到这一点，空间大小并不是问题，容器能根据需要自动扩容。

&nbsp;

Thu,Feb20,2020

